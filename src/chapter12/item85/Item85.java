package chapter12.item85;

import java.util.HashSet;
import java.util.Set;

public class Item85 {
    // 자바 직렬화의 대안을 찾으라.

    // 직렬화와 역직렬화 : 객체를 데이터 스트림으로 변환하거나 반대로 데이터 스트림에서 객체로 변화하는 프로세스로 객체를 파일에 저장하거나 네트워크를 통해 전송할때 유용하다.
    // Serialization 인터페이스를 구현.
    // ObjectOutputStream , ObjectInputStream 을 사용.

    // 직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는것.

    // 자바의 역직렬화는 명백하고 현존하는 위험이다. 이 기술은 지금도 애플리케이션에서 직접 혹은 자바 하부 시스템 을 통해 간접적으로 쓰이고 있다.
    // 신뢰할수 없는 스트림을 역직렬화 하면 원격 코드 실행, 서비스 거부 등의 공격으로 이어질수 있다.

    // 가젯 : 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드.


    // 역직렬화 폭탄
    static byte[] bomb() {
        Set<Object> root = new HashSet<>();
        Set<Object> s1 = root;
        Set<Object> s2 = new HashSet<>();

        for (int i = 0; i < 100; i++) {
            Set<Object> t1 = new HashSet<>();
            Set<Object> t2 = new HashSet<>();
            t1.add("foo");
            s1.add(t1);
            s1.add(t2);
            s2.add(t1);
            s2.add(t2);
            s1 = t1;
            s2 = t2;
        }

        return serialize(root);
    }

    // 이 객체 그래프는 201 개의 HashSet 인스턴스로 구성되며 그 각각은 3개 이하의 객체 참조를 갖는다.
    // 스트림의 전체 크기는 5744 바이트지만 역직렬화는 끝나지 않을것이다.
    // 루트 HashSet 에 담긴 두 원소는 각각 다른 HashSet 2개씩을 원소로 갖는 HashSet 이다.
    // 반복문에 의해 이 구조가 깊이 100단계 까지 만들어지며 이 HashSet 을 역직렬화 하려면 hashCode 메서드를 2의 100승 넘게 호출해야 한다.


    // 따라서 직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화 하지 않는것이다.
    // 역직렬화 를 사용하지 않고 객체의 바이트 시퀀스를 변환해주는 크로스 플랫폼 구조화된 데이터 표현 을 사용하자.
    // 크로스 플랫폼 구조화된 데이터 표현의 예로는 JSON 이 있다.

    // 만약 레거시 시스템 때문에 자바 직렬화를 사용하지 않을수 없을 때에는 신뢰할수 없는 데이터는 절대 역직렬화 하지 않아야 한다.
    // 직렬화를 피할수 없고 역직렬화 한 데이터가 안전한지 확신할수 없다면 객체 역직렬화 필터링 (ObjectInputFilter) 를 사용하자.

    // 1. 블랙리스트 : 잠재적으로 위험한 클래스들을 거부한다
    // 2. 화이트리스트 : 안전하다고 알려진 클래스들만 수용한다.
    // 블랙 << 화이트
}
